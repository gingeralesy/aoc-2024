(in-package #:aoc-2024)

(declaim (inline heap-parent heap-left heap-right heap-swap))
(defun heap-parent (index)
  (floor (1- index) 2))
(defun heap-left (index)
  (1+ (* 2 index)))
(defun heap-right (index)
  (+ 2 (* 2 index)))
(defun heap-swap (array i j)
  (let ((tmp (aref array i)))
    (setf (aref array i) (aref array j))
    (setf (aref array j) tmp)))

(defstruct (heap (:constructor make-heap (predicate &key (capacity #x100)
                                                         (key #'identity)
                                                         (element-type T)
                                                         (initial-element NIL))))
  (array (make-array capacity :element-type element-type :initial-element initial-element)
   :type simple-array)
  (capacity #x100 :type (unsigned-byte 32))
  (size 0 :type (unsigned-byte 32))
  (key #'identity :type function)
  (predicate NIL :type function)
  (element-type T :type (and (not null) (or symbol list)))
  (initial-element NIL :type T))

(defmethod heap-push ((heap heap) value)
  (unless (< (heap-size heap) (heap-capacity heap))
    (heap-increase-capacity heap))
  (let ((index (heap-size heap))
        (array (heap-array heap))
        (key-f (heap-key heap))
        (predicate-f (heap-predicate heap)))
    (incf (heap-size heap))
    (setf (aref array index) value)
    (loop while (and (< 0 index)
                     (funcall predicate-f
                              (funcall key-f (aref array index))
                              (funcall key-f (aref array (heap-parent index)))))
          do (heap-swap array index (heap-parent index))
          do (setf index (heap-parent index)))))

(defmethod heap-pop ((heap heap))
  (when (< 0 (heap-size heap))
    (let* ((array (heap-array heap))
           (root (aref array 0)))
      (setf (aref array 0) (heap-initial-element heap))
      (cond
        ((< 1 (heap-size heap))
         (heap-swap array 0 (1- (heap-size heap)))
         (decf (heap-size heap))
         (heap-heapify heap 0))
        (T (decf (heap-size heap))))
      root)))

(defmethod heap-peek ((heap heap))
  (when (< 0 (heap-size heap)) (aref (heap-array heap) 0)))

(defmethod heap-heapify ((heap heap) index)
  (let ((left (heap-left index))
        (right (heap-right index))
        (smallest index)
        (array (heap-array heap))
        (key-f (heap-key heap))
        (predicate-f (heap-predicate heap)))
    (when (and (< left (heap-size heap))
               (funcall predicate-f
                        (funcall key-f (aref array left))
                        (funcall key-f (aref array smallest))))
      (setf smallest left))
    (when (and (< right (heap-size heap))
               (funcall predicate-f
                        (funcall key-f (aref array right))
                        (funcall key-f (aref array smallest))))
      (setf smallest right))
    (unless (= smallest index)
      (heap-swap array index smallest)
      (heap-heapify heap smallest))))

(defmethod heap-increase-capacity ((heap heap))
  (let* ((array (heap-array heap))
         (new-capacity (* 2 (heap-capacity heap)))
         (new-array (make-array new-capacity
                                :element-type (heap-element-type heap)
                                :initial-element (heap-initial-element heap))))
    (dotimes (i (heap-size heap))
      (setf (aref new-array i) (aref array i))
      (setf (aref array i) (heap-initial-element heap)))
    (setf (heap-capacity heap) new-capacity)
    (setf (heap-array heap) new-array)
    heap))
